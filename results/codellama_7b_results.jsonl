{"task_id": "HumanEval/0", "completion": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n\tfor i in range(len(numbers) - 1):\n\t\tfor j in range(i + 1, len(numbers)):\n\t\t\tif abs(numbers[i] - numbers[j]) < threshold:\n\t\t\t\treturn True\n\treturn False", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": null, "loc_score": 0.88, "functional_correctness": 1.0, "overall_score": 0.1382084646002237}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string):\n    stack = []\n    groups = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n        if not stack:\n            groups.append(''.join(stack))\n    return groups", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.909090909090909, "efficiency_score": 0.999995231628418, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return abs(number) % 1", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999982515970866, "loc_score": 0.8200000000000001, "functional_correctness": 1.0, "overall_score": 0.7793928219469014}
{"task_id": "HumanEval/3", "completion": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        if operation < 0:\n            balance -= operation\n        else:\n            balance += operation\n        if balance < 0:\n            return True\n    return False", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.33333333333333337, "efficiency_score": null, "loc_score": 0.8, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/4", "completion": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    return sum(abs(x - statistics.mean(numbers))) / len(numbers)", "result": "failed: name 'x' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": null, "loc_score": 0.8, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/5", "completion": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    return [delimeter if i != len(numbers)-1 else num for i, num in enumerate(numbers)]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(paren_string):\n    stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if len(stack) > max_level:\n                max_level = len(stack)\n    return [max_level] * len(paren_string)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.909090909090909, "efficiency_score": 0.9999954700469971, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [string for string in strings if substring in string]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.14977744774437016}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers):\n    if not numbers:\n        return 0, 1\n    else:\n        return sum(numbers), reduce(lambda x, y: x * y, numbers)", "result": "failed: name 'reduce' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999985694885254, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/9", "completion": "def rolling_max(numbers):\n\treturn [max(numbers[:i+1]) for i in range(len(numbers))]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24893313651093396}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string. Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 49)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/11", "completion": "def string_xor(a: str, b: str) -> str:\n\t\"\"\" Input are two strings a and b consisting only of 1s and 0s.\n\tPerform binary XOR on these inputs and return result also as a string.\n\t>>> string_xor('010', '110')\n\t'100'", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 28)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/12", "completion": "def longest(strings: List[str]) -> Optional[str]:\\\\n    \\\"\\\"\\\" Out of list of strings, return the longest one. Return the first one in case of multiple\\\\n    strings of the same length. Return None in case the input list is empty.\\\\n    >>> longest([])\\\\n\\\\n    >>> longest(['a', 'b', 'c'])\\\\n    'a'\\\\n    >>> longest(['a', 'bb', 'ccc'])\\\\n    'ccc'\\\\\"\\\"\\\"\\\\n    if not strings:\\\\n        return None\\\\n\\\\n    return max(strings, key=len)\\\\n", "result": "failed: unexpected character after line continuation character (<string>, line 14)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    if a < b:\n        return greatest_common_divisor(b, a)\n    while b != 0:\n        divisor = b\n        b = a % b\n        a = divisor\n    return a", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5, "efficiency_score": 0.9999984900156657, "loc_score": 0.72, "functional_correctness": 1.0, "overall_score": 0.7085165043365202}
{"task_id": "HumanEval/14", "completion": "def all_prefixes(string):\n\treturn [string[:i] for i in range(len(string)+1)]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join(str(i) for i in range(n+1))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.84, "functional_correctness": 1.0, "overall_score": 0.24076021608228154}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999985694885254, "loc_score": 0.84, "functional_correctness": 1.0, "overall_score": 0.24795495683813204}
{"task_id": "HumanEval/17", "completion": "def parse_music(music_string: str) -> List[int]:\n    \\\"\\\"\\\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \\\"\\\"\\\"\n    notes = music_string.split(' ')\n    beats = []\n    for note in notes:\n        if note == 'o':\n            beats.append(4)\n        elif note == 'o|':\n            beats.append(2)\n        else:\n            beats.append(1)\n    return beats", "result": "failed: unexpected character after line continuation character (<string>, line 18)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.5800000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    return string.count(substring)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999969005584717, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n\t\"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n\tValid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n\tReturn the string with numbers sorted from smallest to largest\n\t>>> sort_numbers('three one five')\n\t'one three five'", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 32)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/20", "completion": "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\\n    other and return them in order (smaller number, larger number).\\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\\n    (2.0, 2.2)\\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\\n    (2.0, 2.0)\\n    \"\"\"\\n\\n    smallest = None\\n    largest = None\\n    for i in range(len(numbers) - 1):\\n        for j in range(i + 1, len(numbers)):\\n            if abs(numbers[i] - numbers[j]) < abs(smallest or 0) or smallest is None:\\n                smallest = abs(numbers[i] - numbers[j])\\n                closest_pair = (numbers[i], numbers[j])\\n    return closest_pair", "result": "failed: unexpected character after line continuation character (<string>, line 12)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/21", "completion": "def rescale_to_unit(numbers):\n\treturn [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2489331216733485}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.14977744774437016}
{"task_id": "HumanEval/23", "completion": "def strlen(string):\n    return len(string)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.810719899593419}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n):\n\tfor i in range(n-1, 0, -1):\n\t\tif n % i == 0:\n\t\t\treturn i", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.92, "functional_correctness": 1.0, "overall_score": 0.23821213032324576}
{"task_id": "HumanEval/25", "completion": "def factorize(n: int) -> List[int]:\n\\\\t\\\"\\\"\\\" Return list of prime factors of given integer in the order from smallest to largest.\n\\\\tEach of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n\\\\tInput number should be equal to the product of all factors\n\\\\t>>> factorize(8)\n\\\\t[2, 2, 2]\n\\\\t>>> factorize(25)\n\\\\t[5, 5]\n\\\\t>>> factorize(70)\n\\\\t[2, 5, 7]\n\\\\t\\\"\\\"\\\"\n\\\\tfactors = []\n\\\\tfactor = 2\n\\\\twhile factor <= n:\n\\\\t\\tn //= factor\n\\\\t\\tfactors.append(factor)\n\\\\t\\tfactor += 1\n\\\\treturn factors", "result": "failed: unexpected character after line continuation character (<string>, line 16)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.64, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers):\n\treturn list(dict.fromkeys(numbers).keys())", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/27", "completion": "def flip_case(string):\n    return string.swapcase()", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8107199479161323}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings):\n    return ''.join(strings)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8107199479161323}
{"task_id": "HumanEval/29", "completion": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [string for string in strings if string.startswith(prefix)]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.14977744774437016}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n\treturn [x for x in l if x > 0]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2407602208657613}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n\treturn n > 1 and all(n % i for i in range(2, int(n ** 0.5) + 1))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24076021608228151}
{"task_id": "HumanEval/32", "completion": "def poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\na solution.\n    \"\"\"\n    return -1.0 if len(xs) % 2 == 1 or abs(max(xs)) < 1e-6 else (-b + math.sqrt(d)) / (2 * a)\n\nif __name__ == \"__main__\":\n    xs = [1, 2]\n    print(round(poly(xs, -0.5), 2))\n    xs = [-6, 11, -6, 1]\n    print(round(poly(xs, 1.0), 2))", "result": "failed: name 'b' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.75, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999981721242269, "loc_score": 0.5800000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/33", "completion": "def sort_third(l):\n\treturn l[::3] + sorted(l[1::3]) + l[2::3]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n    return sorted(set(l))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2563721579948057}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.84, "functional_correctness": 1.0, "overall_score": 0.24795500117598493}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += 1\n    return count", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.6666666666666667, "efficiency_score": 0.9999980131785074, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/37", "completion": "def sort_even(l: list):\n    return sorted(l, key=lambda x: x % 2 == 0)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999987284342448, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.75, "max_cyclomatic_complexity": 0.6, "style_score": 0.2, "efficiency_score": 0.9999990463256836, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n: int):\\n\\t\\\"\\\"\\\"\\n\\tprime_fib returns n-th number that is a Fibonacci number and it's also prime.\\n\\t>>> prime_fib(1)\\n\\t2\\n\\t>>> prime_fib(2)\\n\\t3\\n\\t>>> prime_fib(3)\\n\\t5\\n\\t>>> prime_fib(4)\\n\\t13\\n\\t>>> prime_fib(5)\\n\\t89\\n\\\"\\\"\\\"\\n\\treturn next(x for x in itertools.takewhile(lambda y: is_prime(y), itertools.count(1, lambda a, b: a + b, 1)) if x >= n) }", "result": "failed: unexpected character after line continuation character (<string>, line 17)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    # check if there are at least three elements in the list\n    if len(l) = 2 and sum(unique_elements - {element}) == -element:\n            return True\n\n    # if no triples were found, return False\n    return False", "result": "failed: invalid syntax (<string>, line 22)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n):\n\treturn (n * (n - 1)) // 2", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list):\n\treturn [x+1 for x in l]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2489331414567952}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n\tfor i in range(len(l)): # Check each element in the list\n\t\tfor j in range(i+1, len(l)): # Compare each element with every other element after it\n\t\t\tif l[i] + l[j] == 0: return True\nreturn False", "result": "failed: 'return' outside function (<string>, line 23)", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": null, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int):\n    return bin(x)[2:].zfill(base).replace('0', '1')", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999978542327881, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    return (a * h)/2", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.256372142713822}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int):\n\tmemo = [0, 0]\n\tfor i in range(2, n+1):\n\t\tmemo.append(memo[i-1] + memo[i-2] + memo[i-3] + memo[i-4])\n\treturn memo[-1]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999989668528239, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    return sorted(l)[len(l) // 2]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str):\n\treturn text == text[::-1]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999993642171224, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2563721630884664}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int):\n    return pow(2, n) % p", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2563721478074836}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.85, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.8200000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    return ''.join([char for char in text if char not in 'aeiou'])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int):\n    return all(x < t for x in l)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999984900156657, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24893309694403348}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int):\n\treturn x + y", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.25637213252649804}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str):\n    return sorted(s0) == sorted(s1)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    a, b = 0, 1\n    for i in range(n-1):\n        a, b = b, a+b\n    return a", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets):\n\treturn len(brackets) % 2 == 0 and all(b == '>' for b in brackets[1:])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n\treturn all(l[i] = l[i+1] for i in range(len(l)-1))", "result": "failed: invalid syntax (<string>, line 13)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/58", "completion": "def common(l1, l2):\n    return sorted(set(l1).intersection(set(l2)))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999984900156657, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.25637210705818275}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    if n < 2:\n        return n\n\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n = n // i\n        else:\n            i += 1\n\n    return n", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.7777777777777778, "efficiency_score": 0.999999205271403, "loc_score": 0.8, "functional_correctness": 1.0, "overall_score": 0.7816711903781113}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int):\n    return (n * (n + 1)) // 2", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2563721579948057}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str):\\n\\t\\\"\\\"\\\" brackets is a string of \\\"(\\\" and \\\").\\\\nreturn True if every opening bracket has a corresponding closing bracket.\\\\n\\\\n>>> correct_bracketing(\\\"(\\\")\\\\nFalse\\\\n>>> correct_bracketing(\\\"()\\\")\\\\nTrue\\\\n>>> correct_bracketing(\\\"(()())\\\")\\\\nTrue\\\\n>>> correct_bracketing(\\\"())\\\\\")\\\\nFalse\\\"\\\"\\\"\\n\\tstack = []\\n\\tfor bracket in brackets:\\n\\t\\tif bracket == '(':\\n\\t\\t\\tstack.append(bracket)\\n\\t\\telse:\\n\\t\\t\\ts = len(stack) > 0 and stack.pop() == '('\\n\\t\\t\\tif not s:\\n\\t\\t\\t\\treturn False\\n\\treturn True", "result": "failed: unexpected character after line continuation character (<string>, line 16)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/62", "completion": "def derivative(xs):\n\treturn [i for i in xs[1:]]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999985694885254, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int):\n    if n <= 1:\n        return 0\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.25, "efficiency_score": 0.9999991257985433, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    count = 0\n    for c in s:\n        if c.lower() in 'aeiouy':\n            count += 1\n    return count", "result": "failed: Test 4", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5, "efficiency_score": 0.9999991257985433, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string. If shift > number of digits,\n    return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    str_x = str(x)\n    if len(str_x) == shift:\n        return str_x[::-1]\n    else:\n        return str_x[shift:] + str_x[:shift]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.4, "efficiency_score": 0.9999989668528239, "loc_score": 0.72, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n\treturn sum([ord(c) for c in s if c.isupper()])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999993642171224, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24076023043271993}
{"task_id": "HumanEval/67", "completion": "def fruit_distribution(s, n):\n    apples = int(s.split('apples')[0])\n    oranges = int(s.split('oranges')[0])\n    return n - apples - oranges", "result": "failed: invalid literal for int() with base 10: '5 apples and 6 '", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.25, "efficiency_score": 0.9999990463256836, "loc_score": 0.92, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\\n\\t\"\"\" \"\"\"\\n\\tif not arr:\\n\\t\\treturn []\\n\\t\"\"\" \"\"\"\\n\\teven_values = []\\n\\t\"\"\" \"\"\"\\n\\tfor i, node in enumerate(arr):\\n\\t\\tif node % 2 == 0:\\n\\t\\t\\teven_values.append((node, i))\\n\\t\"\"\" \"\"\"\\n\\tif not even_values:\\n\\t\\treturn []\\n\\t\"\"\" \"\"\"\\n\\tsmallest = min(even_values, key=lambda x: (x[0], x[1]))\\n\\t\"\"\" \"\"\"\\n\\treturn [smallest[0], smallest[1]]\" }\"", "result": "failed: unexpected character after line continuation character (<string>, line 36)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/69", "completion": "def search(lst):\n\n    # Find the greatest integer in the list that has a frequency greater than or equal to its value\n    greatest = None\n    for i in lst:\n        if i > 0 and (greatest is None or greatest = i:\n                return i\n\n    # If no such integer exists, return -1\n    return -1", "result": "failed: invalid syntax (<string>, line 18)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n\treturn sorted(lst, key=lambda x: -x if x > lst[0] else x)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999985694885254, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n\n    if a + b > c and b + c > a and c + a > b:\n        return round((a * b * math.sin(math.radians(60))), 2)\n    else:\n        return -1", "result": "failed: name 'math' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999984900156657, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n    return sum(q) <= w and q == q[::-1]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24893313156507244}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n\n    # find the minimum number of elements that need to be changed to make the array palindromic\n    # a palindromic array is an array that is read the same backwards and forwards\n    # in one change, you can change one element to any other element\n\n    # create a copy of the input array\n    arr_copy = arr.copy()\n\n    # reverse the array\n    arr_copy.reverse()\n\n    # find the number of elements that are different between the original and reversed arrays\n    diff_count = 0\n    for i in range(len(arr)):\n        if arr[i] != arr_copy[i]:\n            diff_count += 1\n\n    # return the minimum number of elements that need to be changed\n    return diff_count", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.75, "efficiency_score": 0.999999205271403, "loc_score": 0.7, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n\tif len(lst1) == 0 and len(lst2) == 0:\n\t\treturn []\n\n\tcount = 0\n\tfor item in lst1:\n\t\tcount += len(item)\n\n\tother_count = 0\n\tfor item in lst2:\n\t\tother_count += len(item)\n\n\tif count  other_count:\n\t\treturn lst2\n\telse:\n\t\treturn lst1", "result": "failed: invalid syntax (<string>, line 28)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n\tif a > 100:\n\t\treturn False\n\tfor i in range(2, int(a ** 0.5) + 1):\n\t\tif a % i == 0:\n\t\t\treturn False\n\treturn True", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n\treturn x == n ** int(round(log(x, n)))", "result": "failed: name 'log' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n\treturn a == (a ** 3) or a == (-(a ** 3))", "result": "failed: Fourth test error: False", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    count = 0\n    for char in num:\n        if ord(char) > 47 and ord(char)  64 and ord(char) < 71:\n            if is_prime(int(char, 16)):\n                count += 1\n    return count\ndef is_prime(n):\n    if n == 1 or n == 0:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "result": "failed: invalid syntax (<string>, line 23)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.72, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    return 'db' + binary + 'db'", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.6666666666666667, "efficiency_score": 0.9999992847442627, "loc_score": 0.94, "functional_correctness": 1.0, "overall_score": 0.8666020226392299}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n\treturn len(s) >= 3 and all(s[i] != s[i+1] == s[i+2] for i in range(0, len(s), 3))", "result": "failed: abcd", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.999998410542806, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n\treturn [chr(64 + int((g - 0.3) / 0.1)).upper() for g in grades]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/82", "completion": "def prime_length(string):\n\t\"\"\"Write a function that takes a string and returns True if the string length is a prime number or False otherwise\\nexamples\\nprime_length('Hello') == True\\nprime_length('abcdcba') == True\\nprime_length('kittens') == True\\nprime_length('orange') == False\"\"\"\n\tdef is_prime(n):\n\t\tif n < 2:\n\t\t\treturn False\n\t\tfor i in range(2, int(n ** 0.5) + 1):\n\t\t\tif n % i == 0:\n\t\t\t\treturn False\n\t\treturn True\n\n\treturn is_prime(len(string))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.8, "functional_correctness": 1.0, "overall_score": 0.24494892561131465}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n\tcount = 0\n\tfor i in range(10**(n-1), 10**n):\n\t\tif str(i)[0] == '1' or str(i)[-1] == '1':\n\t\t\tcount += 1\n\treturn count", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.88, "functional_correctness": 1.0, "overall_score": 0.22667357564945484}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n\treturn bin(N)[2:].count('1')", "result": "failed: Error", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    words = s.split()\n    return ' '.join([''.join(sorted(word)) for word in words])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.33333333333333337, "efficiency_score": 0.9999993642171224, "loc_score": 0.94, "functional_correctness": 1.0, "overall_score": 0.7075776025682963}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n\tcoordinates = []\n\tfor i, row in enumerate(lst):\n\t\tfor j, num in enumerate(row):\n\t\t\tif num == x:\n\t\t\t\tcoordinates.append((i, j))\n\treturn sorted(coordinates, key=lambda tup: (tup[0], -tup[1]))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999989668528239, "loc_score": 0.86, "functional_correctness": 1.0, "overall_score": 0.22537451976235098}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n\n    # check if the array is empty\n    if not array:\n        return array\n\n    # calculate the sum of the first and last elements\n    sum = array[0] + array[-1]\n\n    # sort the array based on the sum\n    if sum % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)\n\n# test the function with different arrays\nprint(sort_array([]))\nprint(sort_array([5]))\nprint(sort_array([2, 4, 3, 0, 1, 5]))\nprint(sort_array([2, 4, 3, 0, 1, 5, 6]))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.7272727272727273, "efficiency_score": 0.9999988079071045, "loc_score": 0.6799999999999999, "functional_correctness": 1.0, "overall_score": 0.7670539915089614}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n\treturn ''.join(chr((ord(c) - ord('a') + 2 * 26) % 26 + ord('a')) for c in s)", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999984900156657, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n\tif len(lst) < 2:\n\t\treturn None\n\telse:\n\t\tsmallest = min(lst)\n\t\tfor i in range(len(lst)):\n\t\t\tif lst[i] == smallest:\n\t\t\t\tif i < len(lst) - 1:\n\t\t\t\t\treturn lst[i + 1]\n\t\t\t\telse:\n\t\t\t\t\treturn None", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.005, "efficiency_score": 0.9999989668528239, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n\treturn sum([1 for s in S.split('.') if s.strip().startswith('I')])", "result": "failed: Test 2", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n    return (x == y + z and isinstance(x, int) and isinstance(y, int) and isinstance(z, int))", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999986489613851, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    return ''.join([chr((ord(c) - 97 + 2) % 26 + 97) if c.islower() else chr((ord(c) - 65 + 2) % 26 + 65) for c in message])", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/94", "completion": "def skjkasdkd(lst):\n\n    # Find the largest prime value in the list\n    prime_values = []\n    for i in lst:\n        if is_prime(i):\n            prime_values.append(i)\n\n    # Return the sum of the digits of the largest prime value\n    return sum(str(prime_values[-1]))", "result": "failed: name 'is_prime' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999971389770508, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(dict):\n\tfor key in dict:\n\t\tif not all(c.islower() or c.isupper() for c in key):\n\t\t\treturn False\n\treturn True", "result": "failed: Second test error: True", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.005, "efficiency_score": 0.9999969800313314, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    if n < 0:\n        return []\n    prime_numbers = []\n    for i in range(2, n+1):\n        is_prime = True\n        for j in range(2, int(i ** 0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            prime_numbers.append(i)\n    return prime_numbers", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.8461538461538461, "efficiency_score": 0.9999969005584717, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n\n    # Get the unit digits of both numbers\n    unit_a = a % 10\n    unit_b = b % 10\n\n    # Multiply the unit digits\n    product = unit_a * unit_b\n\n    # Return the product\n    return product", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.4, "efficiency_score": 0.9999962647755941, "loc_score": 0.84, "functional_correctness": 1.0, "overall_score": 0.7415578577405995}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n\tcount = 0\n\tfor i in range(len(s)):\n\t\tix = i * 2\n\t\tidx = ix + 1\n\t\tif idx < len(s) and s[ix].isupper() and s[idx].islower():\n\t\t\tcount += 1\n\treturn count", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.005, "efficiency_score": 0.9999949932098389, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/99", "completion": "def closest_integer(value):\n    try:\n        x = float(value)\n        if round(x) == x:\n            return int(x)\n        else:\n            if round(x) > 0:\n                return int(round(x))\n            else:\n                return int(round(x)) - 1\n    except ValueError:\n        return value\n\ndef test():\n    assert closest_integer(\"10\") == 10\n    assert closest_integer(\"15.3\") == 15\n    assert closest_integer(\"14.5\") == 15\n    assert closest_integer(\"-14.5\") == -15\n    assert closest_integer(\"abc\") == \"abc\"\n\ntest()", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.4, "style_score": 0.7647058823529411, "efficiency_score": null, "loc_score": 0.62, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n\tstones = []\n\tfor i in range(1, n+1):\n\t\tif i % 2 == 0:\n\t\t\tnxt = i + 1\n\t\telse:\n\t\t\tnxt = i + 2\n\t\tstones.append(nxt)\n\treturn stones", "result": "failed: Test 3", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999972184499105, "loc_score": 0.8200000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/101", "completion": "def words_string(s):\n\treturn s.split(', ')\nor words_string(s).split(' ')", "result": "failed: invalid syntax (<string>, line 13)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.94, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n\tif x % 2 == 0:\n\t\treturn x\n\telse:\n\t\tfor i in range(x+1, y+1):\n\t\t\tif i % 2 == 0:\n\t\t\t\treturn i\n\treturn -1", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999990463256836, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n\tif n > m:\n\t\treturn -1\n\taverage = (n + m) // 2\n\treturn str(bin(round(average))[2:]).zfill(len(str(m - n + 1)))", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999989668528239, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n\treturn sorted([i for i in x if not any(j % 2 == 0 for j in str(i))])", "result": "failed: not all arguments converted during string formatting", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n\t\"\"\"\n\tGiven an array of integers,\nsort the integers that are between 1 and 9 inclusive,\nreverse the resulting array,\nand then replace each digit by its corresponding name from\n'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'.\n\nFor example:\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]\n        -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n        -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n  return ['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']\n\n  If the array is empty, return an empty array:\n  arr = []\n  return []\n\n  If the array has any strange number ignore it:\n  arr = [1, -1 , 55]\n        -> sort arr -> [-1, 1, 55]\n        -> reverse arr -> [55, 1, -1]\n  return = ['One']", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 61)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.6, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/106", "completion": "def f(n):\n\tresult = []\n\tfac = 1\n\tfor i in range(1, n+1):\n\t\tresult.append(fac) if i % 2 == 0 else result.append(sum(range(i+1)))\n\tfac *= i + 1\n\treturn result", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n\tcount_even = 0\n\tcount_odd = 0\n\tfor i in range(1, n+1):\n\t\tis_palindrome = str(i) == str(i)[::-1]\n\t\tif is_palindrome:\n\t\t\tif i % 2 == 0:\n\t\t\t\tcount_even += 1\n\t\t\telse:\n\t\t\t\tcount_odd += 1\n\treturn (count_even, count_odd)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.78, "functional_correctness": 1.0, "overall_score": 0.21993982647048513}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    count = 0\n    for num in arr:\n        if sum(map(abs, str(num))) > 0:\n            count += 1\n    return count", "result": "failed: bad operand type for abs(): 'str'", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.8333333333333334, "efficiency_score": 0.9999986489613851, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n\n    # Check if the array is empty\n    if not arr:\n        return True\n\n    # Initialize a variable to keep track of the number of right shift operations\n    count = 0\n\n    # Loop through the array and check if the element needs to be moved\n    for i in range(len(arr) - 1):\n        if arr[i + 1] < arr[i]:\n            count += 1\n\n    # Check if the number of right shift operations is even\n    if count % 2 == 0:\n        return True\n\n    # If the number of right shift operations is odd, it means that some elements need to be moved more than once\n    else:\n        return False", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.6, "efficiency_score": 0.9999991257985433, "loc_score": 0.6799999999999999, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n\treturn 'YES' if all(i % 2 == 0 for i in lst1) else 'NO'", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\n    letter_count = {}\n    for letter in test.split():\n        if letter not in letter_count:\n            letter_count[letter] = 1\n        else:\n            letter_count[letter] += 1\n    return {k: v for k, v in sorted(letter_count.items(), key=lambda x: -x[1])}", "result": "failed: This prints if this assert fails 2 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.7142857142857143, "efficiency_score": 0.9999992847442627, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\\n\" +\n\"    res = ''.join([char for char in s if char not in c])\\n\" +\n\"    return (res, res == res[::-1])", "result": "failed: unexpected character after line continuation character (<string>, line 13)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.94, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n\treturn [sum([int(c) % 2 for c in s]) for s in lst]", "result": "failed: Test 1", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n\treturn min([sum(nums[i:j+1]) for i in range(len(nums)) for j in range(i, len(nums))])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24076022564924074}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n\timport math\n\n\t# Initialize variables\n\twells = []\n\tbuckets = []\n\tnum_wells = len(grid)\n\tbucket_capacity = capacity\n\n\t# Iterate through the grid and find all wells\n\tfor i in range(num_wells):\n\t\tfor j in range(len(grid[i])):\n\t\t\tif grid[i][j] == 1:\n\t\t\t\twells.append((i, j))\n\n\t# Iterate through the wells and find the maximum amount of water that can be filled\n\tmax_water = 0\n\tfor i in range(len(wells)):\n\t\tfor j in range(i + 1, len(wells)):\n\t\t\tif wells[i][1] - wells[j][1] <= bucket_capacity:\n\t\t\t\tmax_water += wells[i][0]\n\n\t# Return the maximum amount of water that can be filled\n\treturn max_water", "result": "failed: Error", "passed": false, "avg_cyclomatic_complexity": 0.30000000000000004, "max_cyclomatic_complexity": 0.30000000000000004, "style_score": 0.005, "efficiency_score": 0.9999988079071045, "loc_score": 0.6, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8107199318085622}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n    words = s.split()\n    return [word for word in words if word.count('[a-z]') == n]", "result": "failed: First test error: []", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.94, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n\t'''You are given a word. Your task is to find the closest vowel that stands between 2 consonants from the right side of the word (case sensitive).\n\tVowels in the beginning and ending doesn't count. Return empty string if you didn't find any vowel met the above condition.\n\tYou may assume that the given string contains English letter only.\n\tExample:\n\tget_closest_vowel(\"yogurt\") ==> \"u\"\n\tget_closest_vowel(\"FULL\") ==> \"U\"\n\tget_closest_vowel(\"quick\") ==> \"\"\n\tget_closest_vowel(\"ab\") ==> \"\"'''\n\n\t# Find the index of the first consonant from the right side of the word\n\tfirst_consonant_index = len(word) - 1\n\n\twhile first_consonant_index >= 0 and word[first_consonant_index].islower():\n\t\tfirst_consonant_index -= 1\n\n\t# Find the index of the second consonant from the right side of the word\n\tsecond_consonant_index = len(word) - 1\n\n\twhile second_consonant_index >= 0 and word[second_consonant_index].islower():\n\t\tsecond_consonant_index -= 1\n\n\t# Check if the first consonant is before the second consonant\n\tif first_consonant_index < second_consonant_index:\n\t\treturn \"\"\n\n\t# Return the vowel between the two consonants\n\treturn word[first_consonant_index + 1:second_consonant_index]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.005, "efficiency_score": 0.9999974568684896, "loc_score": 0.56, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    stack = []\n    for char in lst:\n        if char == '(':\n            stack.append(char)\n        else:\n            stack.pop()\n    return 'Yes' if not stack else 'No'", "result": "failed: pop from empty list", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.8571428571428571, "efficiency_score": 0.999999205271403, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    return sorted(arr, reverse=True)[:k]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n\treturn sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.23165839563388615}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n\treturn sum([x for x in arr[:k] if len(str(x)) <= 2])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24076021129880149}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n\treturn sorted([x for x in collatz_sequence(n) if is_odd(x)])", "result": "failed: name 'collatz_sequence' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999992847442627, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/124", "completion": "def valid_date(date):\n\t# Check if the date string is empty\n\tif not date:\n\t\treturn False\n\n\t# Split the date string into its components\n\tdays, months, years = date.split('-')\n\n\t# Check if the number of days is valid for the month\n\tif months in ('01', '03', '05', '07', '08', '10', '12'):\n\t\tif int(days)  31:\n\t\t\treturn False\n\telif months in ('04', '06', '09', '11'):\n\t\tif int(days)  30:\n\t\t\treturn False\n\telif months == '02':\n\t\tif int(days)  29:\n\t\t\treturn False\n\n\t# Check if the number of months is valid\n\tif int(months)  12:\n\t\treturn False\n\n\t# Check if the date is in the correct format\n\tif len(days) != 2 or len(months) != 2 or len(years) != 4:\n\t\treturn False\n\n\t# If all checks passed, return True\n\treturn True", "result": "failed: invalid syntax (<string>, line 32)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.52, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n\treturn txt.split() if ' ' in txt else txt.split(',') if ',' in txt else sum([1 for c in txt if ord(c) % 2])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.005, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n\treturn lst == sorted(set(lst))", "result": "failed: This prints if this assert fails 7 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.9999993642171224, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n\tstart = max(interval1[0], interval2[0])\n\tend = min(interval1[1], interval2[1])\n\tif start  2:\n\t\t\tis_prime = True\n\t\t\tfor i in range(3, int(length ** 0.5) + 1, 2):\n\t\t\t\tif length % i == 0:\n\t\t\t\t\tis_prime = False\n\t\t\t\t\tb = True\n\t\t\t\t\tsum += 1\n\t\t\t\t\tif sum > 1:\n\t\t\t\t\t\tis_prime = False\n\t\t\t\t\t\tb = False\n\t\t\t\t\tsum = 0\n\t\t\t\t\tbreak\n\t\t\tif is_prime:\n\t\t\t\treturn \"YES\"\n\t\telse:\n\t\t\treturn \"NO\"", "result": "failed: invalid syntax (<string>, line 25)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.62, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n    if not arr:\n        return None\n\n    signs = []\n    for num in arr:\n        if num > 0:\n            signs.append(1)\n        elif num < 0:\n            signs.append(-1)\n        else:\n            signs.append(0)\n\n    return sum([abs(num) for num in arr]) * reduce(lambda x, y: x*y, signs)", "result": "failed: name 'reduce' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.36363636363636365, "efficiency_score": 0.9999989668528239, "loc_score": 0.76, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n\n    # Initialize the minimum path value to infinity\n    min_path = float('inf')\n\n    # Loop through all possible starting points\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            # Calculate the minimum path value for this starting point\n            current_path = calculatePathValue(grid, i, j, k)\n\n            # Update the minimum path value if necessary\n            min_path = min(min_path, current_path)\n\n    # Return the minimum path value\n    return min_path\n\ndef calculatePathValue(grid, i, j, k):\n\n    # Initialize the path value to 0\n    path_value = 0\n\n    # Loop through the first k cells of the grid\n    for row in range(i, min(i + k, len(grid))):\n        for col in range(j, min(j + k, len(grid[0]))):\n            path_value += grid[row][col]\n\n    # Return the calculated path value\n    return path_value", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.7692307692307692, "efficiency_score": 0.9999982515970866, "loc_score": 0.5800000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n    if n == 0:\n        return [1]\n    elif n % 2 == 0:\n        return [1] + list(map(lambda x: round((x / 2) + 1), range(n)))\n    else:\n        return [1] + tri(n - 1) + tri(n - 2) + tri(n + 1)", "result": "failed: maximum recursion depth exceeded in comparison", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5, "efficiency_score": 0.9999988079071045, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n\tproduct = 1\n\todd_digits = []\n\tfor digit in str(n):\n\t\tdigit = int(digit)\n\t\tif digit % 2 == 1:\n\t\t\todd_digits.append(digit)\n\t\tproduct *= digit\n\treturn product if odd_digits else 0", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.8200000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n\tstack = []\n\tfor char in string:\n\t\tif char == '[':\n\t\t\tstack.append(char)\n\t\telif char == ']':\n\t\t\tif len(stack) > 0 and stack[-1] == '[':\n\t\t\t\tstack.pop()\n\t\telse:\n\t\t\tstack.append(char)\n\treturn len(stack) > 0", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.005, "efficiency_score": 0.9999991257985433, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/133", "completion": "def sum_squares(lst):\n\treturn sum([int(round(x) ** 2) for x in lst])", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999993642171224, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n\treturn txt[-1].isalpha() and txt[-2:-1] != ' '", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999993642171224, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n\n    largest = -1\n    for i in range(len(arr) - 1):\n        if arr[i] >= arr[i + 1]:\n            largest = i\n    return largest", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.8333333333333334, "efficiency_score": 0.9999974568684896, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\\n\" +\n\"    largest = None\\n\" +\n\"    smallest = None\\n\" +\n\"    for i in lst:\\n\" +\n\"        if largest is None or i > largest:\\n\" +\n\"            largest = i\\n\" +\n\"        if smallest is None or i < smallest:\\n\" +\n\"            smallest = i\\n\" +\n\"    return (largest, smallest)\\n", "result": "failed: unexpected character after line continuation character (<string>, line 14)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.8200000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n\tif a == b:\n\t\treturn None\n\telif a > b:\n\t\treturn a\n\telse:\n\t\treturn b", "result": "failed: '>' not supported between instances of 'int' and 'str'", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999988079071045, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n\treturn n % 2 == 0 and sum(range(1, n + 1), start = 2)) % 2 == 0", "result": "failed: invalid syntax (<string>, line 10)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n\treturn n * special_factorial(n-1) if n > 0 else 1", "result": "failed: Test 4", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/140", "completion": "def fix_spaces(text):\n\treturn re.sub(' +', '-', text.replace(' ', '_'))", "result": "failed: name 're' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.999999205271403, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/141", "completion": "def file_name_check(file_name):\\n\" +\n\"    if len(file_name) > 3:\\n\" +\n\"        return 'No'\\n\" +\n\"    if not any(c.isalpha() for c in file_name if c.isalpha()) or not any(c.isdigit() for c in file_name if c.isdigit()):\\n\" +\n\"        return 'No'\\n\" +\n\"    if file_name.count('.') != 1:\\n\" +\n\"        return 'No'\\n\" +\n\"    if not file_name.split('.')[0].isalpha():\\n\" +\n\"        return 'No'\\n\" +\n\"    if file_name.split('.')[1] not in ['txt', 'exe', 'dll']:\\n\" +\n\"        return 'No'\\n\" +\n\"    else:\\n\" +\n\"        return 'Yes'", "result": "failed: unexpected character after line continuation character (<string>, line 16)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n\n    result = 0\n    for i, x in enumerate(lst):\n        if i % 3 == 0:\n            result += x ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            result += x ** 3\n\n    return result", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.75, "efficiency_score": 0.999999205271403, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n\twords = sentence.split()\n\tprime_words = [word for word in words if is_prime(len(word))]\n\treturn ' '.join(prime_words)\n\ndef is_prime(n):\n\tif n == 1:\n\t\treturn False\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.65, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.999998410542806, "loc_score": 0.78, "functional_correctness": 1.0, "overall_score": 0.22438525683979876}
{"task_id": "HumanEval/144", "completion": "def simplify(x, n):\n\treturn x.split('/')[0] == int(x.split('/')[0]) * int(n.split('/')[1])", "result": "failed: test1", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.005, "efficiency_score": 0.999995231628418, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n    return sorted(nums, key=lambda x: sum(map(int, str(x))))", "result": "failed: invalid literal for int() with base 10: '-'", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999959468841553, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n\tcount = 0\n\tfor num in nums:\n\t\tif num > 10 and (num % 10) % 2 == 1:\n\t\t\tcount += 1\n\treturn count", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999971389770508, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n\t# create a list of numbers from 1 to n^2\n\ta = list(range(1, n*n+1))\n\t# count the number of triples that meet the condition\n\tcount = 0\n\tfor i in range(n-1):\n\t\tfor j in range(i+1, n-1):\n\t\t\tfor k in range(j+1, n):\n\t\t\t\tif a[i] + a[j] + a[k] % 3 == 0:\n\t\t\t\t\tcount += 1\n\treturn count", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.005, "efficiency_score": 0.9999948342641195, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\\n\" +\n\"    planet_names = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\\n\" +\n\"    planet1_index = planet_names.index(planet1)\\n\" +\n\"    planet2_index = planet_names.index(planet2)\\n\" +\n\"    return tuple(planet_names[i] for i in range(planet1_index+1, planet2_index+1))\\n\" +\n\"}", "result": "failed: unexpected character after line continuation character (<string>, line 18)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    return sorted(lst, key=lambda x: (len(x), x))", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.5, "efficiency_score": 0.9999967416127523, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/150", "completion": "def x_or_y(n, x, y):\n\treturn x if is_prime(n) else y", "result": "failed: name 'is_prime' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.005, "efficiency_score": 0.9999950726826986, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n\treturn sum([x**2 for x in lst if x > 0 and x % 2 == 1])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.999997059504191, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.2316582667598002}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    return [abs(g - s) for g, s in zip(guess, game)]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.5, "efficiency_score": 0.9999961058298746, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.7871951021363945}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\\n\"\n+ \"    strongest = 0\\n\"\n+ \"    strongest_extension = ''\\n\"\n+ \"    for extension in extensions:\\n\"\n+ \"        cap = len([c for c in extension if c.isupper()])\\n\"\n+ \"        sm = len([c for c in extension if c.islower()])\\n\"\n+ \"        strength = cap - sm\\n\"\n+ \"        if strength > strongest:\\n\"\n+ \"            strongest = strength\\n\"\n+ \"            strongest_extension = class_name + '.' + extension\\n\"\n+ \"    return strongest_extension", "result": "failed: unexpected character after line continuation character (<string>, line 19)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(str1, str2):\n\t# Check if str2 is a substring of str1\n\tif str2 in str1:\n\t\treturn True\n\t# Check if any rotation of str2 is a substring of str1\n\tfor i in range(len(str2)): # Generate all rotations of str2\n\t\trotation = str2[i:] + str2[:i]\n\t\tif rotation in str1:\n\t\t\treturn True\n\t# If no match found, return False\n\treturn False", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.005, "efficiency_score": 0.9999315738677979, "loc_score": 0.78, "functional_correctness": 1.0, "overall_score": 0.2199361076634196}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n\tcount = 0\n\teven_count = 0\nodd_count = 0\n\tfor digit in str(abs(num)):\n\t\tdigit = int(digit)\n\t\tif digit % 2 == 0:\n\t\t\teven_count += 1\n\t\telse:\n\t\todd_count += 1\n\treturn (even_count, odd_count)", "result": "failed: unexpected indent (<string>, line 13)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n\t\"\"\"\n\tGiven a positive integer, obtain its roman numeral equivalent as a string,\n\toreturn it in lowercase.\n\tRestrictions: 1 >> int_to_mini_roman(19) == 'xix'\n\t>>> int_to_mini_roman(152) == 'clii'\n\t>>> int_to_mini_roman(426) == 'cdxxvi'\n\t\"\"\"\n\tif number  1000:\n\t\treturn ''\n\n\tid = [('M', 1000), ('D', 500), ('C', 100),\n\t\t('L', 50), ('X', 10), ('V', 5), ('I', 1)]\n\n\tresult = ''\n\n\tfor i in id:\n\t\twhile number >= i[1]:\n\t\t\tnumber -= i[1]\n\t\t\tresult += i[0]\n\n\treturn result", "result": "failed: invalid syntax (<string>, line 21)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.64, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n\treturn (a**2 + b**2 == c**2) or (a**2 + c**2 == b**2) or (b**2 + c**2 == a**2)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.9999887943267822, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.24075959422748522}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\\n\\t\\\"\\\"\\\"Write a function that accepts a list of strings.\\\\nThe list contains different words. Return the word with maximum number\\\\nof unique characters. If multiple strings have maximum number of unique\\\\ncharacters, return the one which comes first in lexicographical order.\\\\n\\\\nfind_max([\"name\", \"of\", \"string\"]) == \"string\"\\\\nfind_max([\"name\", \"enam\", \"game\"]) == \"enam\"\\\\nfind_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\"\\\"\\\"\\\"\\n\\tunique_chars = []\\n\\tresult = ''\\n\\tfor word in words:\\n\\t\\tunique_chars.append(len(set(word)))\\n\\t\\tif len(set(word)) > len(result):\\n\\t\\t\\tresult = word\\n\\treturn result", "result": "failed: unexpected character after line continuation character (<string>, line 12)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    if number + need > remaining:\n        return [remaining, 0]\n    else:\n        return [number + need, remaining - (number + need)]", "result": "failed: Error", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.5, "efficiency_score": 0.9999968210856119, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    result = 0\n    for i in range(len(operand) - 1):\n        op = operator[i]\n        if op == '+':\n            result += operand[i] + operand[i + 1]\n        elif op == '-':\n            result -= operand[i] + operand[i + 1]\n        elif op == '*':\n            result *= operand[i] * operand[i + 1]\n        elif op == '//':\n            result //= operand[i] // operand[i + 1]\n        else:\n            result **= operand[i] ** operand[i + 1]\n    return result", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.8571428571428571, "efficiency_score": 0.9999955495198568, "loc_score": 0.7, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            result += char.lower() if char.isupper() else char.upper()\n        else:\n            result += char\n    return result", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.7142857142857143, "efficiency_score": 0.9999976952870687, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/162", "completion": "import hashlib\n\ndef string_to_md5(text):\n    if text == '':\n        return None\n    else:\n        return hashlib.md5(text.encode()).hexdigest()", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.6, "efficiency_score": 0.9999980131785074, "loc_score": 0.88, "functional_correctness": 1.0, "overall_score": 0.8061776644946148}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    return [x for x in range(a, b+1) if x % 2 == 0]", "result": "failed: Test 1", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.005, "efficiency_score": 0.999996026357015, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
