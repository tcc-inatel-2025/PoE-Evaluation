{"task_id": "HumanEval/0", "completion": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n\tfor i in range(len(numbers)-1):\n\t\tfir = numbers[i]\n\t\tsec = numbers[i+1]\n\t\tdiff = abs(fir-sec)\n\t\tif diff <= threshold:\n\t\t\treturn True\n\treturn False", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/1", "completion": "def separate_paren_groups(paren_string):\n    stack = []\n    result = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            while len(stack) > 0 and stack[-1] != '(':\n                result.append(stack.pop())\n            if len(stack) > 0:\n                stack.pop()\n    while len(stack) > 0:\n        result.append(stack.pop())\n    return [result[i]:result[i+1] for i in range(0, len(result), 2)]", "result": "failed: invalid syntax (<string>, line 25)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.72, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return abs(number) % 1", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999980131785074, "loc_score": 0.8200000000000001, "functional_correctness": 1.0, "overall_score": 0.9036879673198944}
{"task_id": "HumanEval/3", "completion": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        if balance < 0:\n            return True\n        balance += operation\n    return False", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/4", "completion": "def mean_absolute_deviation(numbers: List[float]) -> float:\n\"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0\"\"\"\n    sum = 0.0\n    mean = sum(numbers) / len(numbers)\n    for num in numbers:\n        sum += abs(num - mean)\n    return sum / len(numbers)", "result": "failed: expected an indented block (<string>, line 20)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/5", "completion": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    return [delimeter if i != j else x for i, (x, j) in enumerate(zip(numbers, numbers[1:]))]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(paren_string):\n    # split the string into individual groups\n    groups = paren_string.split(' ')\n\n    # initialize a list to store the levels of nesting\n    levels = []\n\n    # loop through each group and count the number of parentheses\n    for group in groups:\n        level = 0\n        for char in group:\n            if char == '(':\n                level += 1\n            elif char == ')':\n                level -= 1\n        levels.append(level)\n\n    # return the list of levels of nesting\n    return levels", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.75, "efficiency_score": 0.9999984900156657, "loc_score": 0.6799999999999999, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\\n    return [s for s in strings if substring in s]\\n", "result": "failed: unexpected character after line continuation character (<string>, line 11)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \\\"\\\"\\\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \\\"\\\"\\\"\n    return tuple(map(sum, zip(*[numbers] * 2)))", "result": "failed: unexpected character after line continuation character (<string>, line 13)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.8200000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/9", "completion": "def rolling_max(numbers):\n    max_so_far = -float('inf')\n    max_ending_here = 0\n    result = []\n    for num in numbers:\n        max_ending_here = max(max_ending_here, num)\n        max_so_far = max(max_so_far, max_ending_here)\n        result.append(max_so_far)\n    return result", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.6666666666666667, "efficiency_score": 0.9999987284342448, "loc_score": 0.8200000000000001, "functional_correctness": 1.0, "overall_score": 0.8132105552416603}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n\t\"\"\" Test if given string is a palindrome \"\"\"\n\treturn string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n\t\"\"\" Find the shortest palindrome that begins with a supplied string. Algorithm idea is simple:\n\t- Find the longest postfix of supplied string that is a palindrome.\n\t- Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n\t>>> make_palindrome('')\n\t''\n\t>>> make_palindrome('cat')\n\t'catac'\n\t>>> make_palindrome('cata')\n\t'catac'", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 49)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/11", "completion": "def string_xor(a: str, b: str) -> str:\n    return ''.join(['1' if a[i] == b[i] else '0' for i in range(len(a))])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999986489613851, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/12", "completion": "def longest(strings: List[str]) -> Optional[str]: \\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple \\n    strings of the same length. Return None in case the input list is empty. \\n    >>> longest([]) \\n    \\n    >>> longest(['a', 'b', 'c']) \\n    'a' \\n    >>> longest(['a', 'bb', 'ccc']) \\n    'ccc' \\n    \"\"\">\\n    if not strings: \\n        return None \\n    return max(strings, key=len) \\n", "result": "failed: unexpected character after line continuation character (<string>, line 14)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/13", "completion": "def greatest_common_divisor(a: int, b: int) -> int:\n\t\"\"\" Return a greatest common divisor of two integers a and b\n\t>>> greatest_common_divisor(3, 5)\n\t1\n\t>>> greatest_common_divisor(25, 15)\n\t5", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 30)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/14", "completion": "def all_prefixes(string):\n\treturn [string[:i] for i in range(len(string) + 1)]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    return ' '.join(str(i) for i in range(n+1))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9157710544073391}
{"task_id": "HumanEval/16", "completion": "def count_distinct_characters(string: str) -> int:\n\t\"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 31)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/17", "completion": "def parse_music(music_string):\n    notes = {'o': 4, 'o|': 2, '.|': 1}\n    return [notes[note] for note in music_string]", "result": "failed: ' '", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.94, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/18", "completion": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n\n    return count", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5, "efficiency_score": 0.9999985694885254, "loc_score": 0.72, "functional_correctness": 1.0, "overall_score": 0.7085165184134993}
{"task_id": "HumanEval/19", "completion": "def sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\"\"\"\n    return ' '.join(sorted(numbers.split()))", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/20", "completion": "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smallest number, largest number).\\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\\n    (2.0, 2.2)\\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\\n    (2.0, 2.0)\\n    \"\"\"\\n    smallest = None\\n    largest = None\\n    for i in range(len(numbers) - 1):\\n        for j in range(i + 1, len(numbers)):\\n            if abs(numbers[i] - numbers[j]) < abs(smallest or 0) and abs(numbers[i] - numbers[j]) > 0:\\n                smallest = numbers[i]\\n                largest = numbers[j]\\n    return (smallest, largest)", "result": "failed: unexpected character after line continuation character (<string>, line 12)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/21", "completion": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n\treturn [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8763560920082658}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n\treturn [x for x in values if type(x) == int]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8197560612767678}
{"task_id": "HumanEval/23", "completion": "def strlen(string):\n    return len(string)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.952440252714866}
{"task_id": "HumanEval/24", "completion": "def largest_divisor(n):\n\tfor i in range(n-1, 0, -1):\n\t\tif n % i == 0:\n\t\t\treturn i", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.92, "functional_correctness": 1.0, "overall_score": 0.8635651905763124}
{"task_id": "HumanEval/25", "completion": "def factorize(n: int) -> List[int]:\n    factors = []\n    while n > 1:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                factors.append(i)\n                n = n // i\n                break\n        else:\n            factors.append(n)\n            n = 1\n    return factors", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.18181818181818182, "efficiency_score": null, "loc_score": 0.76, "functional_correctness": 1.0, "overall_score": 0.4103366441755251}
{"task_id": "HumanEval/26", "completion": "def remove_duplicates(numbers: List[int]) -> List[int]:\\n    return list(dict.fromkeys(numbers))", "result": "failed: unexpected character after line continuation character (<string>, line 10)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/27", "completion": "def flip_case(string):\n    return string.swapcase()", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524402274837851}
{"task_id": "HumanEval/28", "completion": "def concatenate(strings):\n\treturn ''.join(strings)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524403031770239}
{"task_id": "HumanEval/29", "completion": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [string for string in strings if string.startswith(prefix)]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8197560612767678}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n\treturn [x for x in l if x > 0]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8759035263316185}
{"task_id": "HumanEval/31", "completion": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.42857142857142866, "efficiency_score": 0.9999988873799642, "loc_score": 0.86, "functional_correctness": 1.0, "overall_score": 0.6857536190807646}
{"task_id": "HumanEval/32", "completion": "def poly(xs: list, x: float):\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    return -1 if len(xs) % 2 != 0 or xs[0] == 0 else xs[-1] / xs[-2]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.75, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999986489613851, "loc_score": 0.92, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n\t\"\"\"This function takes a list l and returns a list l' such that\n\tl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n\tto the values of the corresponding indicies of l, but sorted.\n\t>>> sort_third([1, 2, 3])\n\t[1, 2, 3]\n\t>>> sort_third([5, 6, 3, 4, 8, 9, 2])\n\t[2, 6, 3, 4, 8, 9, 5]", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 35)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/34", "completion": "def unique(l: list):\n\treturn sorted(set(l))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524402779459457}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    return max(l)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524403031770239}
{"task_id": "HumanEval/36", "completion": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += 1\n    return count", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.42857142857142866, "efficiency_score": 0.9999988873799642, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/37", "completion": "def sort_even(l):\n\treturn sorted(l, key=lambda x: x % 2 == 0)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/38", "completion": "def encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.75, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n):\n\tprev, curr = 0, 1\n\tfor _ in range(n - 1):\n\t\tpriv, curr = curr, priv + curr\n\t\tif is_prime(curr):\n\t\t\treturn curr\n\treturn curr\ndef is_prime(n):\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.76, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l):\n\tfor i in range(len(l)-1):\n\t\tfor j in range(i+1, len(l)): # iterate over all possible pairs of elements\n\t\t\ta = l[i]\n\t\t\tb = l[j]\n\t\t\tc = -a-b\n\t\t\tif c in l:\n\t\t\t\treturn True # if there is a triple, return True\n\treturn False", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.8200000000000001, "functional_correctness": 1.0, "overall_score": 0.7894443635995565}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n):\n\treturn n*(n-1)//2", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/42", "completion": "def incr_list(l: list):\n    return [x + 1 for x in l]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9157711029266868}
{"task_id": "HumanEval/43", "completion": "def pairs_sum_to_zero(l):\n\tif len(l) < 2:\n\t\treturn False\n\n\tpair = (None, None)\n\n\tfor i in range(len(l) - 1):\n\t\tfor j in range(i + 1, len(l)): \n\t\t\tif l[i] + l[j] == 0:\n\t\t\t\tpair = (l[i], l[j])\n\t\t\t\tbreak\n\n\tif pair[0] is not None and pair[1] is not None:\n\t\treturn True\n\n\treturn False", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.30000000000000004, "max_cyclomatic_complexity": 0.30000000000000004, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.76, "functional_correctness": 1.0, "overall_score": 0.6109112478580945}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int):\n\treturn bin(x)[2:].zfill(base)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999986489613851, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    return (a * h)/2", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524402779459457}
{"task_id": "HumanEval/46", "completion": "def fib4(n: int):\n\n    if n <= 2:\n        return 0\n\n    else:\n        a = 0\n        b = 0\n        c = 2\n        d = 0\n\n    for i in range(3, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n\n    return d", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/47", "completion": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if len(l) == 0:\n        return None\n    l = sorted(l)\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n    else:\n        return l[len(l) // 2]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.42857142857142866, "efficiency_score": 0.9999988079071045, "loc_score": 0.72, "functional_correctness": 1.0, "overall_score": 0.6817314167085536}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.74, "functional_correctness": 1.0, "overall_score": 0.8732888733840783}
{"task_id": "HumanEval/49", "completion": "def modp(n: int, p: int):\n    return pow(2, n, p)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524403031770239}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s):\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift(s):\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.92, "functional_correctness": 1.0, "overall_score": 0.9028711761616508}
{"task_id": "HumanEval/51", "completion": "def remove_vowels(text):\n    return ''.join([c for c in text if c not in 'aeiou'])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/52", "completion": "def below_threshold(l: list, t: int):\n    return all(x < t for x in l)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9157710301476634}
{"task_id": "HumanEval/53", "completion": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.84, "functional_correctness": 1.0, "overall_score": 0.910976329572941}
{"task_id": "HumanEval/54", "completion": "def same_chars(s0: str, s1: str):\n    return sorted(s0) == sorted(s1)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    a, b = 0, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    return a", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets):\n    stack = []\n    for char in brackets:\n        if char == '<':\n            stack.append(char)\n        elif char == '>':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.7, "efficiency_score": 0.9999988873799642, "loc_score": 0.8, "functional_correctness": 1.0, "overall_score": 0.7274269501752354}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    return all(l[i] <= l[i+1] for i in range(len(l)-1)) or all(l[i] >= l[i+1] for i in range(len(l)-1))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8320332206415889}
{"task_id": "HumanEval/58", "completion": "def common(l1, l2):\n\treturn sorted(set(l1).intersection(l2))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524402274837851}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n % 2 == 0 and is_prime(n // 2):\n        return n // 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0 and is_prime(i):\n            return i\n    return 1", "result": "failed: name 'is_prime' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int):\n    return sum(range(1, n+1))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.952440252714866}
{"task_id": "HumanEval/61", "completion": "def correct_bracketing(brackets: str):\n    return len(brackets) % 2 == 0 and brackets.count('(') == brackets.count(')')", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/62", "completion": "def derivative(xs):\n    return [xs[i] * (i + 1) for i in range(len(xs))]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/63", "completion": "def fibfib(n: int):\n    if n <= 2:\n        return 0\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/64", "completion": "def vowels_count(s):\n    count = 0\n    for c in s:\n        if c.lower() in 'aeiouy':\n            count += 1\n    return count", "result": "failed: Test 4", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.1666666666666666, "efficiency_score": 0.9999989668528239, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string. If shift > number of digits,\n    return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    str_x = str(x)\n    if len(str_x) == shift:\n        return str_x[::-1]\n    else:\n        return str_x[shift:] + str_x[:shift]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.2, "efficiency_score": 0.9999987284342448, "loc_score": 0.72, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/66", "completion": "def digitSum(s):\n\treturn sum([ord(c) for c in s if c.isupper()])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8759035495351613}
{"task_id": "HumanEval/67", "completion": "def fruit_distribution(s, n):\n\tapples, oranges = map(int, s.split('and'))\n\tmango = n - apples - oranges\n\treturn mango", "result": "failed: invalid literal for int() with base 10: '5 apples '", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.92, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n\tif not arr:\n\t\treturn []\n\tmin_value = float('inf')\n\tmin_index = None\n\tfor i, node in enumerate(arr):\n\t\tif node % 2 == 0 and node < min_value:\n\t\t\tmin_value = node\n\t\t\tmin_index = i\n\treturn [min_value, min_index]", "result": "failed: Error", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.8, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/69", "completion": "def search(lst):\n\n    # find the greatest integer in the list that has a frequency greater than or equal to its value\n    max_freq = 0\n    max_val = -1\n\n    freqs = {}  # dictionary to store frequencies of integers\n\n    for i in lst:\n        if i not in freqs:\n            freqs[i] = 1\n        else:\n            freqs[i] += 1\n\n    for key, val in freqs.items():\n        if val >= key and key > max_val:\n            max_freq = val\n            max_val = key\n\n    if max_freq == 0:\n        return -1\n    else:\n        return max_val", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.30000000000000004, "max_cyclomatic_complexity": 0.30000000000000004, "style_score": 0.6666666666666667, "efficiency_score": 0.9999987284342448, "loc_score": 0.64, "functional_correctness": 1.0, "overall_score": 0.5981393223449674}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    return sorted(lst, key=lambda x: (x, -x))", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    if a + b > c and b + c > a and c + a > b:\n        return round((a * b * math.sqrt(3)) / 4, 2)\n    else:\n        return -1", "result": "failed: name 'math' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999985694885254, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/72", "completion": "def will_it_fly(q, w):\n\treturn sum(q) <= w and q == q[::-1]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9157710301476634}
{"task_id": "HumanEval/73", "completion": "def smallest_change(arr):\n\n    # Check if the array is already palindromic\n    if arr == arr[::-1]:\n        return 0\n\n    # Find the minimum number of elements to change\n    min_changes = len(arr)\n\n    for i in range(len(arr)): \n        for j in range(i+1, len(arr)): \n            if arr[i] == arr[j]:\n                min_changes -= 1\n\n    return min_changes", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.33333333333333337, "efficiency_score": 0.9999988079071045, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/74", "completion": "def total_match(lst1, lst2):\n\treturn lst1 if sum([len(x) for x in lst1]) < sum([len(x) for x in lst2]) else lst2", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/75", "completion": "def is_multiply_prime(a):\n\tfor i in range(2, int(a ** 0.5) + 1):\n\t\tif a % i == 0:\n\t\t\treturn False\n\treturn True", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/76", "completion": "def is_simple_power(x, n):\n\treturn x == n ** int(log(x, n))", "result": "failed: name 'log' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n\treturn a**3 == abs(a)", "result": "failed: Third test error: False", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/78", "completion": "def hex_key(num):\n    count = 0\n    for digit in num:\n        if int(digit, 16) % 2 == 1 and int(digit, 16) % 3 == 2 and int(digit, 16) % 5 == 4 and int(digit, 16) % 7 == 6 and (int(digit, 16) - 10) % 11 == 0 and (int(digit, 16) - 12) % 13 == 0):\n            count += 1\n    return count", "result": "failed: invalid syntax (<string>, line 23)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/79", "completion": "def decimal_to_binary(decimal):\n    return bin(decimal)[2:]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n\treturn len(s) >= 3 and all(s[i] != s[i+1] or s[i+1] != s[i+2] for i in range(len(s)-2))", "result": "failed: aabb", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/81", "completion": "def numerical_letter_grade(grades):\n\treturn [['A+', 4], ['A', 3.7], ['A-', 3.3], ['B+', 2.7], ['B', 2.3], ['B-', 2], ['C+', 1.7], ['C', 1.3], ['C-', 1], ['D+', 0.7], ['D', 0.3], ['D-', 0], ['E', 0]]\n\t\t.filter(lambda x: x[0] <= gpa)\n\t\t.pop()[1]\n\t\tfor gpa in grades]", "result": "failed: unexpected indent (<string>, line 29)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/82", "completion": "def prime_length(string):\n\t\"\"\"Write a function that takes a string and returns True if the string length is a prime number or False otherwise\\nExamples\\nprime_length('Hello') == True\\nprime_length('abcdcba') == True\\nprime_length('kittens') == True\\nprime_length('orange') == False\"\"\"\n\t# Check if the string length is a prime number\n\tis_prime = lambda x: x > 1 and all(x % i for i in range(2, int(x ** 0.5) + 1))\n\treturn is_prime(len(string))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.9, "functional_correctness": 1.0, "overall_score": 0.8572615248762321}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n\treturn sum([int(i.startswith('1')) + int(i.endswith('1')) for i in range(10**n)])", "result": "failed: 'int' object has no attribute 'startswith'", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n\treturn bin(N)[2:].count('1')", "result": "failed: Error", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/85", "completion": "def add(lst):\n\treturn sum(x for i, x in enumerate(lst) if i % 2 == 1)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    return ' '.join([sorted(word, key=lambda c: ord(c)) for word in s.split()])", "result": "failed: sequence item 0: expected str instance, list found", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n\treturn [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n\t\t.sort(key=lambda t: (t[0], -t[1]))", "result": "failed: unexpected indent (<string>, line 24)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.94, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/88", "completion": "def sort_array(array):\n\tif not array:\n\t\treturn []\n\n\tsum = sum(array[0:2])\n\tif sum % 2 == 1:\n\t\treturn sorted(array)\n\telse:\n\t\treturn sorted(array, reverse=True)", "result": "failed: local variable 'sum' referenced before assignment", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/89", "completion": "def encrypt(s):\n\trotated_alphabet = \"\"\n\tfor i in range(len(s)): \n\t\tchar = s[i]\n\t\tif char.isalpha():\n\t\t\tindex = ord(char) - ord('a') + 2 * (ord('a') - ord('A'))\n\t\t\trotated_alphabet += chr(index)\n\t\telse:\n\t\t\trotated_alphabet += char\n\treturn rotated_alphabet", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.8, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n\tif len(lst) < 2:\n\t\treturn None\n\telse:\n\t\tsmallest = None\n\t\tfor i in range(len(lst)):\n\t\t\tif lst[i] > lst[0] and (smallest is None or lst[i] < smallest):\n\t\t\tsmallest = lst[i]\n\treturn smallest", "result": "failed: expected an indented block (<string>, line 20)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.8200000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/91", "completion": "def is_bored(S):\n\treturn sum([1 for s in S.split('.') if s.startswith('I')])", "result": "failed: Test 2", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/92", "completion": "def any_int(x, y, z):\n\treturn (x == y + z and isinstance(x, int) and isinstance(y, int) and isinstance(z, int)) or (y == x + z and isinstance(y, int) and isinstance(x, int) and isinstance(z, int)) or (z == x + y and isinstance(z, int) and isinstance(x, int) and isinstance(y, int))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.0, "max_cyclomatic_complexity": 0.0, "style_score": 0.0, "efficiency_score": 0.9999985694885254, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9797951963083839}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n\treturn \"\".join([chr((ord(c) + 2 - (97 if c.islower() else 65)) % 26 + 97 if c.isalpha() else c) for c in message])", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/94", "completion": "def largest_prime(lst):\n\n    # Find the largest prime value in the list\n    largest_prime = None\n    for num in lst:\n        if is_prime(num) and (largest_prime is None or num > largest_prime):\n            largest_prime = num\n\n    # Return the sum of the digits of the largest prime value\n    return sum(map(int, str(largest_prime)))\n\n# Returns true if the number is prime and false otherwise\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.55, "max_cyclomatic_complexity": 0.5, "style_score": 0.5384615384615384, "efficiency_score": 0.9999988079071045, "loc_score": 0.6799999999999999, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/95", "completion": "def check_dict_case(dict):\n\treturn all((k.islower() if k.isalpha() else True) for k in dict.keys()) or all((k.isupper() if k.isalpha() else True) for k in dict.keys())", "result": "failed: 'int' object has no attribute 'isalpha'", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/96", "completion": "def count_up_to(n):\n    prime_numbers = []\n    for i in range(2, n+1):\n        if all(\n                i % num != 0\n                for num in range(2, int(i ** 0.5) + 1)\n            ):\n            prime_numbers.append(i)\n    return prime_numbers", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.33333333333333337, "efficiency_score": 0.9999989668528239, "loc_score": 0.8200000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n\treturn a * b", "result": "failed: First test error: 60976", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/98", "completion": "def count_upper(s):\n\tcount = 0\n\tfor i in range(len(s)):\n\t\tix = i % 2 == 0\n\t\tif ix and s[i].isupper():\n\t\t\tcount += 1\n\treturn count", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/99", "completion": "def closest_integer(value):\n\tvalue = float(value)\n\tdiff = abs(round(value) - value)\n\tif diff == 0:\n\t\treturn round(value)\n\telse:\n\t\treturn round(value) if diff > 0.5 else round(value) - 1", "result": "failed: Test 2", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n\treturn [n] + [i for i in range(n+1, n*2, 2)]", "result": "failed: Test 3", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999991257985433, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/101", "completion": "def words_string(s):\n\treturn s.split(',') if ',' in s else s.split()", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/102", "completion": "def choose_num(x, y):\n\tif x % 2 == 0 and y % 2 == 0:\n\t\tfor num in range(x, y + 1, 2):\n\t\t\tif num in range(x, y + 1):\n\t\t\t\treturn num\n\treturn -1", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n\tif n > m:\n\t\treturn -1\n\telse:\n\t\treturn bin(round((sum(range(n, m + 1)) / len(range(n, m + 1)))), 0)).replace('0b', '')", "result": "failed: invalid syntax (<string>, line 17)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/104", "completion": "def unique_digits(x):\n\treturn [i for i in x if not any(j % 2 == 0 for j in str(i))]", "result": "failed: not all arguments converted during string formatting", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/105", "completion": "def by_length(arr):\n\t\"\"\"\n\tGiven an array of integers, sort the integers that are between 1 and 9 inclusive,\n\treverse the resulting array, and then replace each digit by its corresponding name from\n\t\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n\tFor example:\n\t\tar = [2, 1, 1, 4, 5, 8, 2, 3]\n\t\t\t-> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n\t\t\t-> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n\treturn ['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']\n\n\tIf the array is empty, return an empty array:\n\tar = []\n\treturn []\n\n\tIf the array has any strange number ignore it:\n\tar = [1, -1 , 55]\n\t\t-> sort arr -> [-1, 1, 55]\n\t\t-> reverse arr -> [55, 1, -1]\n\treturn = ['One']", "result": "failed: EOF while scanning triple-quoted string literal (<string>, line 59)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.64, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/106", "completion": "def f(n):\n\treturn [fibonacci(i) if i % 2 == 0 else sum(range(1, i + 1)) for i in range(1, n + 1)]", "result": "failed: name 'fibonacci' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n\tcount_even = 0\n\tcount_odd = 0\n\tfor i in range(1, n+1):\n\t\tis_palindrome = str(i) == str(i)[::-1]\n\t\tif is_palindrome:\n\t\t\tif i % 2 == 0:\n\t\t\t\tcount_even += 1\n\t\t\telse:\n\t\t\t\tcount_odd += 1\n\treturn (count_even, count_odd)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.78, "functional_correctness": 1.0, "overall_score": 0.7763933197218295}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n\treturn sum(1 for i in arr if sum(map(lambda x: abs(x), str(i))) > 0)", "result": "failed: bad operand type for abs(): 'str'", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/109", "completion": "def move_one_ball(arr):\n\n    # Check if the array is empty\n    if not arr:\n        return True\n\n    # Check if the array is already sorted\n    if arr == sorted(arr):\n        return True\n\n    # Perform right shift operation until the array is sorted\n    while arr != sorted(arr):\n        arr.insert(0, arr.pop())\n\n    # Return True if the array is sorted\n    return arr == sorted(arr)", "result": "timed out", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.625, "efficiency_score": 0.9999989668528239, "loc_score": 0.76, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/110", "completion": "def exchange(lst1, lst2):\n\n    # Check if both lists are empty\n    if not lst1 and not lst2:\n        return \"YES\"\n\n    # Check if all elements in lst1 are even\n    if all(\n            element % 2 == 0\n            for element in lst1)\n        return \"YES\"\n\n    # Check if there is an element in lst2 that can be exchanged with an element in lst1 to make it even\n    for element in lst2:\n        if element % 2 != 0 and element in lst1:\n            return \"YES\"\n\n    # If none of the above conditions are met, then it is not possible to exchange elements between lst1 and lst2\n    return \"NO\"", "result": "failed: invalid syntax (<string>, line 24)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.7, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/111", "completion": "def histogram(test):\\n\\t'''Given a string representing a space separated lowercase letters, return a dictionary\\nof the letter with the most repetition and containing the corresponding count.\\nIf several letters have the same occurrence, return all of them.\\n\\nExample:\\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\\nhistogram('a b b a') == {'a': 2, 'b': 2}\\nhistogram('a b c a b') == {'a': 2, 'b': 2}\\nhistogram('b b b b a') == {'b': 4}\\nhistogram('') == {}}\\n\\n    '''\\n\\tletter_count = {} # create an empty dictionary to store the count of each letter\\n\\n\\tfor char in test.lower().split():\\n\\t\\t# check if the current character is already in the dictionary, and increase its count if it exists\\n\\t\\tif char in letter_count:\\n\\t\\t\\tletter_count[char] += 1\\n\\t\\t# otherwise, add the character to the dictionary with a count of 1\\n\\t\\telse:\\n\\t\\t\\tletter_count[char] = 1\\n\\n\\treturn letter_count", "result": "failed: unexpected character after line continuation character (<string>, line 15)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.98, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/112", "completion": "def reverse_delete(s, c):\n    # Delete all characters in s that are equal to any character in c\n    result = ''.join([char for char in s if char not in c])\n\n    # Check if the result string is a palindrome\n    return (result, result == result[::-1])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.9, "functional_correctness": 1.0, "overall_score": 0.8572615475859354}
{"task_id": "HumanEval/113", "completion": "def odd_count(lst):\n    return [sum(c % 2 for c in s) for s in lst]", "result": "failed: not all arguments converted during string formatting", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    return min(sum(nums[i:j+1]) for i in range(len(nums)) for j in range(i, len(nums)))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8759035495351613}
{"task_id": "HumanEval/115", "completion": "def max_fill(grid, capacity):\n\n    # Initialize variables\n    num_wells = len(grid)\n    num_buckets = len(grid[0])\n    curr_level = [0 for _ in range(num_buckets)]\n    next_level = [0 for _ in range(num_buckets)]\n    filled_wells = 0\n    total_level = 0\n\n    # Loop until all wells are filled\n    while filled_wells < num_wells:\n        # Fill the wells with water\n        for i in range(num_wells):\n            if grid[i][j] == 1 and curr_level[j] < capacity:\n                curr_level[j] += 1\n                filled_wells += 1\n\n        # Calculate the total level of water in all wells\n        for j in range(num_buckets):\n            total_level += curr_level[j]\n\n        # Swap the current and next levels\n        curr_level, next_level = next_level, curr_level\n\n        # Reset the next level\n        for j in range(num_buckets):\n            next_level[j] = 0\n\n    # Return the total number of times we need to lower the buckets\n    return math.ceil(total_level / capacity)", "result": "failed: local variable 'j' referenced before assignment", "passed": false, "avg_cyclomatic_complexity": 0.09999999999999998, "max_cyclomatic_complexity": 0.09999999999999998, "style_score": 0.2777777777777778, "efficiency_score": 0.9999985694885254, "loc_score": 0.5, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/116", "completion": "def sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9524402779459457}
{"task_id": "HumanEval/117", "completion": "def select_words(s, n):\n\twords = s.split()\n\tresult = []\n\tfor word in words:\n\t\tif len([c for c in word if c.islower() and not c.istitle()]) == n:\n\t\t\tresult.append(word)\n\treturn result", "result": "failed: First test error: ['lamb']", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/118", "completion": "def get_closest_vowel(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in vowels:\n            return word[i]\n    return ''", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5, "efficiency_score": 0.9999988079071045, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/119", "completion": "def match_parens(lst):\n    stack = []\n    for char in lst:\n        if char == '(':\n            stack.append(char)\n        else:\n            stack.pop()\n    return 'Yes' if not stack else 'No'", "result": "failed: pop from empty list", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.5714285714285714, "efficiency_score": 0.9999988873799642, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/120", "completion": "def maximum(arr, k):\n    return sorted(arr, reverse=True)[:k]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999986489613851, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/121", "completion": "def solution(lst):\n\treturn sum([lst[i] for i in range(len(lst)) if i % 2 == 1 and lst[i] % 2 == 1])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/122", "completion": "def add_elements(arr, k):\n    return sum([x for x in arr[:k] if len(str(x)) <= 2])", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8759034799245293}
{"task_id": "HumanEval/123", "completion": "def get_odd_collatz(n):\n\tseq = [n]\n\todd_nums = []\n\twhile seq[-1] != 1:\n\t\tif seq[-1] % 2 == 0:\n\t\t\tseq.append(seq[-1] // 2)\n\t\telse:\n\t\t\tseq.append((3 * seq[-1]) + 1)\n\tfor i in range(len(seq)-1):\n\t\teven = False\n\t\tif seq[i] % 2 == 0:\n\t\t\teven = True\n\t\t\tbreak\n\t\todd_nums.append(seq[i])\n\treturn sorted(odd_nums)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.7, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/124", "completion": "def valid_date(date):\n\t# Check if date is empty\n\tif not date:\n\t\treturn False\n\n\t# Split the date into its components\n\tdays, months, years = date.split('-')\n\n\t# Check if the days, months and years are valid\n\tif len(days) > 2 or len(months) > 2 or len(years) > 4:\n\t\treturn False\n\n\t# Check if the number of days is valid for each month\n\tif months in ('01', '03', '05', '07', '08', '10', '12'):\n\t\tif int(days) < 1 or int(days) > 31:\n\t\t\treturn False\n\telif months in ('04', '06', '09', '11'):\n\t\tif int(days) < 1 or int(days) > 30:\n\t\t\treturn False\n\telif months == '02':\n\t\tif int(days) < 1 or int(days) > 29:\n\t\t\treturn False\n\n\t# Check if the number of months is valid\n\tif int(months) < 1 or int(months) > 12:\n\t\treturn False\n\n\t# Check if the date is in the format mm-dd-yyyy\n\tif '-' not in date or date.count('-') != 2:\n\t\treturn False\n\n\t# If all checks pass, return True\n\treturn True", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.0, "max_cyclomatic_complexity": 0.0, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.45999999999999996, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/125", "completion": "def split_words(txt):\n\tif txt.strip():\n\t\tsplit = txt.split()\n\telse:\n\t\tsplit = txt.split(',')\n\treturn split", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/126", "completion": "def is_sorted(lst):\n\treturn lst == sorted(lst)", "result": "failed: This prints if this assert fails 5 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/127", "completion": "def intersection(interval1, interval2):\n\tstart = max(interval1[0], interval2[0])\n\tend = min(interval1[1], interval2[1])\n\tif start <= end:\n\t\treturn 'YES' if len(set(range(start, end + 1))) == 1 else 'NO'\n\telse:\n\t\treturn 'NO'", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/128", "completion": "def prod_signs(arr):\n\tif not arr:\n\t\treturn None\n\tproduct = 1\n\tsigns = []\n\tfor i in arr:\n\t\tsigns.append(1 if i > 0 else -1 if i < 0 else 0)\n\tfor s in signs:\n\t\tproduct *= s\n\treturn sum([abs(i) for i in arr]) * product", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.30000000000000004, "max_cyclomatic_complexity": 0.30000000000000004, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.8, "functional_correctness": 1.0, "overall_score": 0.6214462707127436}
{"task_id": "HumanEval/129", "completion": "def minPath(grid, k):\n\n    # Initialize a set to store the visited cells\n    visited = set()\n\n    # Initialize a queue to store the cells to be visited\n    queue = [(0, 0)]\n\n    # Initialize a variable to store the minimum path length\n    min_path_length = float('inf')\n\n    # Loop until the queue is empty or the minimum path length is found\n    while queue and min_path_length > k:\n        # Get the current cell from the queue\n        row, col = queue.pop(0)\n\n        # If the current cell has not been visited before and its value is less than the minimum path length,\n        # mark it as visited and add its neighbors to the queue\n        if (row, col) not in visited and grid[row][col] < min_path_length:\n            visited.add((row, col))\n            for neighbor in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]):\n                    queue.append(neighbor)\n\n            min_path_length = grid[row][col]\n\n    # Return the values of the cells in the minimum path, ordered by row then column\n    return [grid[row][col] for row, col in visited if grid[row][col] < min_path_length]", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.0, "max_cyclomatic_complexity": 0.0, "style_score": 0.6153846153846153, "efficiency_score": 0.9999986489613851, "loc_score": 0.5800000000000001, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/130", "completion": "def tri(n):\n\tif n == 0:\n\t\treturn [1]\n\telse:\n\t\tn = len(tri(n-1)) + len(tri(n-2))\n\t\tfor i in range(n-3, -1, -1):\n\t\t\ttri[i] += tri[i+1] + tri[i+2]\n\treturn tri", "result": "failed: maximum recursion depth exceeded in comparison", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.84, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/131", "completion": "def digits(n):\n\treturn sum([int(i) for i in str(n) if int(i) % 2 != 0])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999990463256836, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/132", "completion": "def is_nested(string):\n\tstack = []\n\tresult = False\n\n\tfor char in string:\n\t\tif char == '[':\n\t\t\tstack.append(char)\n\t\telif char == ']':\n\t\t\tif not stack or stack[-1] != '[':\n\t\t\t\tresult = True\n\t\t\t\tbreak\n\t\telse:\n\t\t\tstack.pop()\n\n\treturn result", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.0, "efficiency_score": 0.9999986489613851, "loc_score": 0.74, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/133", "completion": "def sum_squares(lst):\n\treturn sum([int(round(x)) ** 2 for x in lst])", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/134", "completion": "def check_if_last_char_is_a_letter(txt):\n    if len(txt) == 0:\n        return False\n\n    if txt[-1].isalpha() and not txt[-2:].isalnum():\n        return True\n    else:\n        return False", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.1666666666666666, "efficiency_score": 0.9999988873799642, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    largest_idx = -1\n    for i in range(len(arr) - 1):\n        if arr[i] >= arr[i + 1]:\n            largest_idx = i\n            break\n    return largest_idx", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.5714285714285714, "efficiency_score": 0.9999988873799642, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/136", "completion": "def largest_smallest_integers(lst):\n\n    largest = None\n    smallest = None\n\n    for num in lst:\n        if num < 0 and (largest is None or num > largest):\n            largest = num\n        elif num > 0 and (smallest is None or num < smallest):\n            smallest = num\n\n    return largest, smallest", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.19999999999999996, "max_cyclomatic_complexity": 0.19999999999999996, "style_score": 0.6666666666666667, "efficiency_score": 0.9999988873799642, "loc_score": 0.8200000000000001, "functional_correctness": 1.0, "overall_score": 0.5750267209933912}
{"task_id": "HumanEval/137", "completion": "def compare_one(a, b):\n\tif a == b:\n\t\treturn None\n\telif isinstance(a, float) or isinstance(b, float):\n\t\treturn max(a, b)\n\telse:\n\t\treturn a if a > b else b", "result": "failed: '>' not supported between instances of 'int' and 'str'", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.0, "efficiency_score": 0.9999986489613851, "loc_score": 0.86, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n\treturn (n % 2 == 0 and n == sum(range(1, n + 1, 2)))", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n\treturn n * special_factorial(n-1) if n > 0 else 1", "result": "failed: Test 4", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/140", "completion": "def fix_spaces(text):\n\treturn text.replace(' ', '_').replace('  ', '-')", "result": "failed: This prints if this assert fails 4 (good for debugging!)", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/141", "completion": "def file_name_check(file_name):\\n\" + \n\"    if len(file_name) > 3:\\n\" +\n\"        return 'No'\\n\" +\n\"    if not any(char.isalpha() for char in file_name[:file_name.index('.')]):\\n\" +\n\"        return 'No'\\n\" +\n\"    if file_name.index('.') == 0:\\n\" +\n\"        return 'No'\\n\" +\n\"    if file_name[file_name.index('.')+1:] not in ['txt', 'exe', 'dll']:\\n\" +\n\"        return 'No'\\n\" +\n\"    else:\\n\" +\n\"        return 'Yes'", "result": "failed: unexpected character after line continuation character (<string>, line 16)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/142", "completion": "def sum_squares(lst):\n\treturn sum([i ** 2 for i in lst if (i % 3 == 0 or i % 4 == 0) and not (i % 3 == 0 and i % 4 == 0)])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.4, "max_cyclomatic_complexity": 0.4, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n\treturn ' '.join([word for word in sentence.split() if is_prime(len(word))])", "result": "failed: name 'is_prime' is not defined", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/144", "completion": "def simplify(x, n):\n\treturn x.split('/')[0] in '123456789' and x.split('/')[1] == n", "result": "failed: test1", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/145", "completion": "def order_by_points(nums):\n\treturn sorted(nums, key=lambda x: sum(map(int, str(abs(x)))))", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/146", "completion": "def specialFilter(nums):\n\tcount = 0\n\tfor num in nums:\n\t\tif num > 10 and str(num)[0] in '13579' and str(num)[-1] in '13579':\n\t\t\tcount += 1\n\treturn count", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.88, "functional_correctness": 1.0, "overall_score": 0.7605902100694335}
{"task_id": "HumanEval/147", "completion": "def get_max_triples(n):\n\treturn sum(1 for i in range(1, n) for j in range(i + 1, n) if (i * i - i + 1 + j * j - j + 1) % 3 == 0)", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\\n\" + \n\"\\t\"\"orbit_order = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\\n\" + \n\"\\t\"\"if planet1 not in orbit_order or planet2 not in orbit_order:\\n\" + \n\"\\t\\t\"\"return ()\\n\" + \n\"\\t\"\"orbit_index_1 = orbit_order.index(planet1)\\n\" + \n\"\\t\"\"orbit_index_2 = orbit_order.index(planet2)\\n\" + \n\"\\t\"\"if orbit_index_1 > orbit_index_2:\\n\" + \n\"\\t\\t\"\"temp = orbit_index_1\\n\" + \n\"\\t\\t\"\"orbit_index_1 = orbit_index_2\\n\" + \n\"\\t\\t\"\"orbit_index_2 = temp\\n\" + \n\"\\t\"\"return tuple(sorted(orbit_order[orbit_index_1+1:orbit_index_2], key=lambda x: abs(x == 'Earth')))\\n", "result": "failed: unexpected character after line continuation character (<string>, line 18)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/149", "completion": "def sorted_list_sum(lst):\n    return sorted(lst, key=lambda x: (len(x), x))", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.9, "max_cyclomatic_complexity": 0.9, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/150", "completion": "def x_or_y(n, x, y):\n\tif n % 2 == 0:\n\t\treturn y\n\telse:\n\t\treturn x", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999985694885254, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n\treturn sum(x**2 for x in lst if x > 0 and x % 2 == 1)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.6, "max_cyclomatic_complexity": 0.6, "style_score": 0.0, "efficiency_score": 0.9999989668528239, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8320332426829659}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n\treturn [abs(g - s) for g, s in zip(guess, game)]", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.9157710301476634}
{"task_id": "HumanEval/153", "completion": "def Strongest_Extension(class_name, extensions):\n\t\"\"\"You will be given the name of a class (a string) and a list of extensions.\n\tThe extensions are to be used to load additional classes to the class. The strength of the extension is as follows: Let CAP be the number of the uppercase letters in the extension's name, and let SM be the number of lowercase letters in the extension's name, the strength is given by the fraction CAP - SM.\n\tYou should find the strongest extension and return a string in this format: ClassName.StrongestExtensionName.\n\tIf there are two or more extensions with the same strength, you should choose the one that comes first in the list.\n\tFor example, if you are given \"Slices\" as the class and a list of the extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension (its strength is -1).\n\tExample:\n\tfor Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\t\"\"\"\n\tstrongest_strength = 0\n\tstrongest_extension = None\n\tfor extension in extensions:\n\t\tcapital_letters = 0\n\t\tlowercase_letters = 0\n\t\tfor char in extension:\n\t\t\tif char.isupper():\n\t\t\t\tcapital_letters += 1\n\t\t\telse:\n\t\t\t\tlowercase_letters += 1\n\t\tstrength = capital_letters - lowercase_letters\n\t\tif strength > strongest_strength or (strength == strongest_strength and extension < strongest_extension):\n\t\t\tstrongest_strength = strength\n\t\t\tstrongest_extension = extension\n\treturn class_name + '.' + strongest_extension", "result": "failed: '<' not supported between instances of 'str' and 'NoneType'", "passed": false, "avg_cyclomatic_complexity": 0.30000000000000004, "max_cyclomatic_complexity": 0.30000000000000004, "style_score": 0.0, "efficiency_score": 0.9999985694885254, "loc_score": 0.52, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/154", "completion": "def cycpattern_check(word1, word2):\n    return any(word2 in word1[i:] for i in range(len(word1)))", "result": "failed: test #3", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.0, "efficiency_score": 0.9999988079071045, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n\tcount = 0\n\teven_count = 0\nodd_count = 0\n\tfor digit in str(abs(num)): # Iterate through the digits of the absolute value of the input number\n\t\tif int(digit) % 2 == 0:\n\t\t\teven_count += 1\n\t\telse:\n\t\todd_count += 1\n\treturn (even_count, odd_count)", "result": "failed: unexpected indent (<string>, line 13)", "passed": false, "avg_cyclomatic_complexity": null, "max_cyclomatic_complexity": null, "style_score": 0.0, "efficiency_score": null, "loc_score": 0.8, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n\t\"\"\"\n\tGiven a positive integer, obtain its roman numeral equivalent as a string,\n\tand return it in lowercase.\n\tRestrictions: 1 <= num <= 1000\n\n\tExamples:\n\t>>> int_to_mini_roman(19) == 'xix'\n\t>>> int_to_mini_roman(152) == 'clii'\n\t>>> int_to_mini_roman(426) == 'cdxxvi'\n\t\"\"\"\n\treturn str((lambda x: {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n\t\t'C': 100, 'D': 500, 'M': 1000}[x])(\n\t\tnumber%10))\n\tif number < 4:\n\t\treturn str(number)\n\telse:\n\t\tresult = ''\n\t\twhile number >= 1000:\n\t\t\tresult += 'M'\n\t\t\tnumber -= 1000\n\t\twhile number >= 900:\n\t\t\tresult += 'CM'\n\t\t\tnumber -= 900\n\t\twhile number >= 500:\n\t\t\tresult += 'D'\n\t\t\tnumber -= 500\n\t\twhile number >= 400:\n\t\t\tresult += 'CD'\n\t\t\tnumber -= 400\n\t\twhile number >= 100:\n\t\t\tresult += 'C'\n\t\t\tnumber -= 100\n\t\twhile number >= 90:\n\t\t\tresult += 'XC'\n\t\t\tnumber -= 90\n\t\twhile number >= 50:\n\t\t\tresult += 'L'\n\t\t\tnumber -= 50\n\t\twhile number >= 40:\n\t\t\tresult += 'XL'\n\t\t\tnumber -= 40\n\t\twhile number >= 10:\n\t\t\tresult += 'X'\n\t\t\tnumber -= 10\n\t\twhile number >= 9:\n\t\t\tresult += 'IX'\n\t\t\tnumber -= 9\n\t\twhile number >= 5:\n\t\t\tresult += 'V'\n\t\t\tnumber -= 5\n\t\twhile number >= 4:\n\t\t\tresult += 'IV'\n\t\t\tnumber -= 4\n\t\treturn result", "result": "failed: 9", "passed": false, "avg_cyclomatic_complexity": 0.0, "max_cyclomatic_complexity": 0.0, "style_score": 0.0, "efficiency_score": 0.9999985694885254, "loc_score": 0.0, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/157", "completion": "def right_angle_triangle(a, b, c):\n\treturn (a**2 + b**2 == c**2) or (a**2 + c**2 == b**2) or (b**2 + c**2 == a**2)", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999985694885254, "loc_score": 0.96, "functional_correctness": 1.0, "overall_score": 0.8759034103138865}
{"task_id": "HumanEval/158", "completion": "def find_max(words):\n\tunique_chars = {}\n\tresult = \"\"\n\tfor word in words:\n\t\tif len(word) > len(result) or (len(word) == len(result) and word < result):\n\t\t\tunique_chars = {}\n\t\t\tresult = word\n\t\t\tfor char in word:\n\t\t\t\tif char not in unique_chars:\n\t\t\t\t\tunique_chars[char] = True\n\treturn result", "result": "failed: t8", "passed": false, "avg_cyclomatic_complexity": 0.30000000000000004, "max_cyclomatic_complexity": 0.30000000000000004, "style_score": 0.0, "efficiency_score": 0.9999987284342448, "loc_score": 0.78, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/159", "completion": "def eat(number, need, remaining):\n    total = number + need\n    if total > remaining:\n        return [total, 0]\n    else:\n        return [total, remaining - total]", "result": "failed: Error", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.2, "efficiency_score": 0.9999985694885254, "loc_score": 0.88, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/160", "completion": "def do_algebra(operator, operand):\n    result = 0\n    for i in range(len(operand) - 1):\n        result = operator[i](result, operand[i + 1])\n    return result", "result": "failed: 'str' object is not callable", "passed": false, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.4, "efficiency_score": 0.9999987284342448, "loc_score": 0.9, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n\t\"\"\"You are given a string s.\\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \\notherwise keep it as it is.\\nIf the string contains no letters, reverse the string.\\nThe function should return the resulted string.\\nExamples\\nsolve(\"1234\") = \"4321\"\\nsolve(\"ab\") = \"AB\"\\nsolve(\"#a@C\") = \"#A@c\"\\n\"\"\"\n\tresult = []\n\tfor c in s:\n\t\tif c.isalpha():\n\t\t\tc = c.lower() if c.islower() else c.upper()\n\t\tresult.append(c)\n\telse:\n\t\tresult.append(c)\n\treturn ''.join(result[::-1])", "result": "failed: ", "passed": false, "avg_cyclomatic_complexity": 0.5, "max_cyclomatic_complexity": 0.5, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.8, "functional_correctness": 0.0, "overall_score": 0.0}
{"task_id": "HumanEval/162", "completion": "import hashlib\n\ndef string_to_md5(text):\n    if text == '':\n        return None\n    else:\n        return hashlib.md5(text.encode('utf-8')).hexdigest()", "result": "passed", "passed": true, "avg_cyclomatic_complexity": 0.8, "max_cyclomatic_complexity": 0.8, "style_score": 0.2, "efficiency_score": 0.9999989668528239, "loc_score": 0.88, "functional_correctness": 1.0, "overall_score": 0.612562704504798}
{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n\treturn [x for x in range(a, b+1) if x%2==0]", "result": "failed: Test 1", "passed": false, "avg_cyclomatic_complexity": 0.7, "max_cyclomatic_complexity": 0.7, "style_score": 0.0, "efficiency_score": 0.9999988873799642, "loc_score": 0.96, "functional_correctness": 0.0, "overall_score": 0.0}
